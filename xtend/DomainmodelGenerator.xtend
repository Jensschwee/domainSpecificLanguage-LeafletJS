/*
 * generated by Xtext 2.11.0
 */
package dk.sdu.mmmi.msd.generator


import java.util.List
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.msd.leafletDSL.ApiKey
import dk.sdu.mmmi.msd.leafletDSL.Attribution
import dk.sdu.mmmi.msd.leafletDSL.BackgroundColor
import dk.sdu.mmmi.msd.leafletDSL.BackgroundOpacity
import dk.sdu.mmmi.msd.leafletDSL.Button
import dk.sdu.mmmi.msd.leafletDSL.DOUBLE
import dk.sdu.mmmi.msd.leafletDSL.DataSource
import dk.sdu.mmmi.msd.leafletDSL.DisableZoomBtn
import dk.sdu.mmmi.msd.leafletDSL.DoubleClickZoom
import dk.sdu.mmmi.msd.leafletDSL.DraggingDisable
import dk.sdu.mmmi.msd.leafletDSL.FALSE
import dk.sdu.mmmi.msd.leafletDSL.INTEGER
import dk.sdu.mmmi.msd.leafletDSL.Icon
import dk.sdu.mmmi.msd.leafletDSL.Include
import dk.sdu.mmmi.msd.leafletDSL.KeyValue
import dk.sdu.mmmi.msd.leafletDSL.KeyboardDisable
import dk.sdu.mmmi.msd.leafletDSL.Layer
import dk.sdu.mmmi.msd.leafletDSL.LineColor
import dk.sdu.mmmi.msd.leafletDSL.LineWidth
import dk.sdu.mmmi.msd.leafletDSL.Map
import dk.sdu.mmmi.msd.leafletDSL.MapContainterOptions
import dk.sdu.mmmi.msd.leafletDSL.MapTilelayerOptions
import dk.sdu.mmmi.msd.leafletDSL.MaxNativeZoom
import dk.sdu.mmmi.msd.leafletDSL.MaxZoom
import dk.sdu.mmmi.msd.leafletDSL.MinZoom
import dk.sdu.mmmi.msd.leafletDSL.Model
import dk.sdu.mmmi.msd.leafletDSL.ModelItems
import dk.sdu.mmmi.msd.leafletDSL.PointerIcon
import dk.sdu.mmmi.msd.leafletDSL.Script
import dk.sdu.mmmi.msd.leafletDSL.ScrollWheelZoom
import dk.sdu.mmmi.msd.leafletDSL.StartZoom
import dk.sdu.mmmi.msd.leafletDSL.Style
import dk.sdu.mmmi.msd.leafletDSL.Styling
import dk.sdu.mmmi.msd.leafletDSL.TRUE
import dk.sdu.mmmi.msd.leafletDSL.TouchZoomDisable
import dk.sdu.mmmi.msd.leafletDSL.Transform
import dk.sdu.mmmi.msd.leafletDSL.ToggleButton
import dk.sdu.mmmi.msd.leafletDSL.TOPRIGHT
import dk.sdu.mmmi.msd.leafletDSL.TOPLEFT
import dk.sdu.mmmi.msd.leafletDSL.BOTTOMLEFT
import dk.sdu.mmmi.msd.leafletDSL.BOTTOMRIGHT
import org.eclipse.xtext.Disjunction
import dk.sdu.mmmi.msd.leafletDSL.LogicExpression
import java.util.LinkedList
import javax.xml.ws.Dispatch
import dk.sdu.mmmi.msd.leafletDSL.AllTypes
import org.eclipse.xtext.CompositeCondition
import org.eclipse.xtext.Condition
import java.awt.CompositeContext
import org.eclipse.xtext.Conjunction
import dk.sdu.mmmi.msd.leafletDSL.Comparison
import org.eclipse.xtext.impl.ConditionImpl
import org.eclipse.emf.ecore.EObject
import dk.sdu.mmmi.msd.leafletDSL.LogicExp
import org.eclipse.emf.common.notify.Notifier
import java.util.Set
import java.util.HashSet
import java.util.HashMap
import dk.sdu.mmmi.msd.leafletDSL.MathOp
import dk.sdu.mmmi.msd.leafletDSL.MathExp
import dk.sdu.mmmi.msd.leafletDSL.MathTerm
import dk.sdu.mmmi.msd.leafletDSL.MapType
import dk.sdu.mmmi.msd.leafletDSL.POINT
import dk.sdu.mmmi.msd.leafletDSL.POLYGON
import dk.sdu.mmmi.msd.leafletDSL.LESS
import dk.sdu.mmmi.msd.leafletDSL.MORE
import dk.sdu.mmmi.msd.leafletDSL.EQ
import dk.sdu.mmmi.msd.leafletDSL.EQLESS
import dk.sdu.mmmi.msd.leafletDSL.EQMORE
import dk.sdu.mmmi.msd.leafletDSL.NOT
import dk.sdu.mmmi.msd.leafletDSL.NumberTypes
import dk.sdu.mmmi.msd.leafletDSL.BOOLEAN
import dk.sdu.mmmi.msd.leafletDSL.OperatorAddMinus
import dk.sdu.mmmi.msd.leafletDSL.MINUS
import dk.sdu.mmmi.msd.leafletDSL.PLUS
import dk.sdu.mmmi.msd.leafletDSL.MULTIPLI
import dk.sdu.mmmi.msd.leafletDSL.DIVISION
import dk.sdu.mmmi.msd.leafletDSL.Value
import dk.sdu.mmmi.msd.leafletDSL.Filter
import dk.sdu.mmmi.msd.leafletDSL.CSSStyle
import dk.sdu.mmmi.msd.leafletDSL.LineOpacity
import dk.sdu.mmmi.msd.leafletDSL.LINESTRING
import dk.sdu.mmmi.msd.leafletDSL.MULTILINESTRING
import dk.sdu.mmmi.msd.leafletDSL.MULTIPOINT
import dk.sdu.mmmi.msd.leafletDSL.GEOMETRYCOLLECTION
import dk.sdu.mmmi.msd.leafletDSL.MULTIPOLYGON
import dk.sdu.mmmi.msd.leafletDSL.LogicComparison
import dk.sdu.mmmi.msd.leafletDSL.SetComparison
import dk.sdu.mmmi.msd.leafletDSL.Assignment
import dk.sdu.mmmi.msd.leafletDSL.CONTAINS
import dk.sdu.mmmi.msd.leafletDSL.SetComparisonOperator
import dk.sdu.mmmi.msd.leafletDSL.SetTypes
import dk.sdu.mmmi.msd.leafletDSL.AllSetTypes
import dk.sdu.mmmi.msd.leafletDSL.SetExpression
import dk.sdu.mmmi.msd.leafletDSL.SetExp
import dk.sdu.mmmi.msd.leafletDSL.UNION
import dk.sdu.mmmi.msd.leafletDSL.INTERSECT
import dk.sdu.mmmi.msd.leafletDSL.DIFF

/**
  * http://stackoverflow.com/questions/18409011/xtend-how-to-stop-a-variable-from-printing-in-output
  */
 class State {
    @Property
    var int counter

    @Property
    var String mapName

    @Property
    var Set<Transform> transforms = new HashSet();

    @Property
    var Set<Assignment> assignments = new HashSet();

 	@Property
    var Set<Layer> layers = new HashSet();

    new(int counter){
        this.counter = counter
    }
}

/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LeafletDSLGenerator extends AbstractGenerator {
	var state = new State(0);
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.allContents.filter(typeof(Model)).next
		state.mapName = resource.allContents.filter(typeof(Map)).next.mapName
		state.transforms = resource.allContents.filter(typeof(Transform)).toSet()
		state.layers = resource.allContents.filter(typeof(Layer)).toSet()
		fsa.generateFile("/Leaflet.html",generateLeafletHTML(model));
	}

	def generateLeafletHTML(Model model)'''
		«generateStaticHeader()»

		«generateInclude(model.includes)»

		«generateStaticHTMLBODY()»

			«generateMaps(model.map)»

			«generateModelItem(model.modelItems)»

		«generateStatickFooter()»'''

	def generateModelItem(EList<ModelItems> modelItems)'''
	«FOR mi : modelItems»
		«generateModelItemMember(mi)»
	«ENDFOR»
	'''

	def dispatch generateModelItemMember(Icon icon) '''
	function getIcon«icon.name»() {
	    return L.icon({
	        iconUrl: '«icon.source»',
	        iconSize: [«icon.size», «icon.size»]
	    });
	}

	function getEasybuttonImage«icon.name»() {
		var height = «icon.size»;
		var width = «icon.size»;
		var imageSrc = '«icon.source»';
		return '<div><img src="' + imageSrc + '" width="' + width + '" height="' + height + '"/></div>';
	}
	'''

	def dispatch generateModelItemMember(Assignment assignment)
	'''
	var assignment«assignment.name» = «assignment.exp.generateAssignment»;
	'''

	def dispatch generateAssignment(dk.sdu.mmmi.msd.leafletDSL.Set set)
	'''«set.generateSet»'''

	def dispatch generateAssignment(NumberTypes num)
	'''«IF(num.int !== null)»«printINTEGER(num.int)»«ELSEIF(num.double !== null)»«printDOUBLE(num.double)»«ENDIF»'''

	def dispatch generateModelItemMember(Styling style) '''
	function style«style.name»() {
		«IF style.base != null»
			var style = style«style.base.name»();
		«ELSE»
			var style = {};
		«ENDIF»
	«FOR styleElement : style.getStyles»	«generateCSSElement(styleElement)»
    «ENDFOR»
		return style;
	}
	'''

	def dispatch generateCSSElement(LineColor style)
	'''
		style["color"] = "«style.color»";
	'''

	def dispatch generateCSSElement(LineWidth style)
	'''
		style["weight"] = «style.value»;
	'''

	def dispatch generateCSSElement(BackgroundColor style)
	'''
		style["fillColor"] = "«style.color»";
	'''

	def dispatch generateCSSElement(BackgroundOpacity style)
	'''
		style["fillOpacity"] = «style.value/100.0»;
	'''

	def dispatch generateCSSElement(LineOpacity style)
	'''
		style["opacity"] = «style.value/100.0»;
	'''

	def dispatch generateCSSElement(PointerIcon style)
	'''
		style["pointerIcon"] = getIcon«style.icon.name»();
	'''

	def dispatch generateModelItemMember(Layer layer) '''
	«IF layer.filter.size() !== 0»
		«state.setCounter(1)»
		«FOR filter : layer.filter»
			«IF filter.expression !== null »
				«var variabels =  filter.expression.findVariabelsForFilter»
				function layer«layer.name»Filter«state.counter»(feature) {
				        if (feature == undefined || feature.properties === undefined «IF variabels.size()  !== 0»||«ENDIF» «FOR str : variabels SEPARATOR "|| "»!feature.properties.«str» === undefined «ENDFOR»)
				            return false;
				            «IF(filter.mapType !== null)»
				            if (feature.geometry.type !== "«filter.mapType.maptypeGenerate»")
				                        return false;
				            «ENDIF»
				         «filter.expression.generateFilterExpression»
				        return false;
				}
				«state.setCounter(state.counter + 1)»
			«ELSEIF filter.mapType !== null»
				 function layer«layer.name»Filter«state.counter»(feature) {
				 				            «IF(filter.mapType !== null)»
				 				            if (feature.geometry.type === "«filter.mapType.maptypeGenerate»")
				 				                        return true;
				 				            «ENDIF»
				 				        return false;
				 }
			«ENDIF»
		«ENDFOR»
	«ENDIF»
	'''

	def generateFilterExpression(LogicExpression expression)'''
	if(«expression.findSubExpression»)
	{
		return true;
	}
	'''

	def dispatch CharSequence findSubExpression(LogicExpression expression)
	{
		//DO NOTHING
	}

	def dispatch CharSequence findSubExpression(LogicComparison expression)
	'''«expression.left.findSubExpression»«expression.operator.findSubExpression»«expression.right.findSubExpression»'''
	def dispatch CharSequence findSubExpression(LESS less)''' < '''
	def dispatch CharSequence findSubExpression(MORE less)''' > '''
	def dispatch CharSequence findSubExpression(EQ less)''' == '''
	def dispatch CharSequence findSubExpression(EQLESS less)''' <= '''
	def dispatch CharSequence findSubExpression(EQMORE less)''' >= '''
	def dispatch CharSequence findSubExpression(NOT less)''' != '''

	def dispatch CharSequence findSubExpression(SetComparison expression) {
		'''(«expression.generateSetExpression»)'''
	}

	def dispatch CharSequence findSubExpression(Disjunction expression)
	'''(«expression.left.findSubExpression» && «expression.right.findSubExpression»)'''

	def dispatch CharSequence findSubExpression(Conjunction expression)
	'''(«expression.left.findSubExpression» || «expression.right.findSubExpression»)'''

	def dispatch CharSequence findSubExpression(AllTypes type)
	'''«IF(type.id !== null)»«var transform = state.transforms.findFirst[it.name==type.id]»«IF(transform !== null)»«transform.findSubExpression»«ELSE»feature.properties.«type.id»«ENDIF»«ELSEIF (type.string !== null)»"«type.string»"«ENDIF»'''

	def dispatch CharSequence findSubExpression(BOOLEAN bool)'''«printBOOLEAN(bool)»'''

	def dispatch CharSequence findSubExpression(NumberTypes num)
	'''«IF(num.int !== null)»«printINTEGER(num.int)»«ELSEIF(num.double !== null)»«printDOUBLE(num.double)»«ENDIF»'''

	def dispatch CharSequence findSubExpression(LogicExp exp)
	'''«IF exp.op.equals("and")»(«ENDIF»«exp.left.findSubExpression»«IF exp.op.equals("and")» && «ELSEIF exp.op.equals("or")» || «ENDIF»«exp.right.findSubExpression»«IF exp.op.equals("and")»)«ENDIF»'''

	def dispatch CharSequence findSubExpression(MathTerm exp)
	{
		if(exp.transform !== null)
		{
			exp.transform.findSubExpression
		}
	}

	def dispatch CharSequence findSubExpression(Transform exp)
	'''transform«exp.name»(feature.properties.«exp.variable»)'''


	def dispatch CharSequence generateSetExpression(SetComparison expression) {
		switch expression.operator {
			CONTAINS: return '''containedWithinSet(«expression.right.generateSetExpression», feature.properties.«expression.left»)'''
			default: return ''' '''
		}
	}

	def dispatch CharSequence generateSetExpression(SetExpression expression) {
		switch expression.op {
			UNION: return '''unionSets(«expression.left.generateSetExpression», «expression.right.generateSetExpression»)'''
			INTERSECT: return '''intersectSets(«expression.left.generateSetExpression», «expression.right.generateSetExpression»)'''
			DIFF: return '''subtractSets(«expression.left.generateSetExpression», «expression.right.generateSetExpression»)'''
			default: return ''' '''
		}
	}

	def dispatch CharSequence generateSetExpression(SetTypes expression) {
		if(expression.set !== null) {
			return expression.set.generateSet
		}
		else if(expression.id !== null) {
			return "assignment" + expression.id
		}
	}

	def generateSet(dk.sdu.mmmi.msd.leafletDSL.Set set)
	'''[«FOR item : set.items SEPARATOR ', '»«item.generateSetItem»«ENDFOR»]'''

	def dispatch CharSequence generateSetItem(AllSetTypes type)
	'''«IF (type.s !== null)»"«type.s»"«ENDIF»'''

	def dispatch CharSequence generateSetItem(BOOLEAN bool)
	'''«printBOOLEAN(bool)»'''

	def dispatch CharSequence generateSetItem(NumberTypes num)
	'''«IF(num.int !== null)»«printINTEGER(num.int)»«ELSEIF(num.double !== null)»«printDOUBLE(num.double)»«ENDIF»'''

	def dispatch getMaptypeGenerate(POINT type)'''Point'''
	def dispatch getMaptypeGenerate(POLYGON type)'''Polygon'''
	def dispatch getMaptypeGenerate(LINESTRING type)'''LineString'''
	def dispatch getMaptypeGenerate(MULTILINESTRING type)'''MultiLineString'''
	def dispatch getMaptypeGenerate(MULTIPOINT type)'''MultiPoint'''
	def dispatch getMaptypeGenerate(GEOMETRYCOLLECTION type)'''GeometryCollection'''
	def dispatch getMaptypeGenerate(MULTIPOLYGON type)'''MultiPolygon'''

	def Set<String> findVariabelsForFilter(LogicExpression dis){
		var variabels = new HashSet<String>();
		dis.findVariable(variabels);
		return variabels;
	}

	def dispatch void findVariable(Disjunction di, Set<String> variabels){
		di.left.findVariable(variabels);
		di.right.findVariable(variabels);
	}

	def dispatch void findVariable(Conjunction con, Set<String> variabels){
		con.left.findVariable(variabels);
		con.right.findVariable(variabels);
	}


	def dispatch void findVariable(SetComparison con, Set<String> variabels){
		if(con.left !== null) {
			variabels.add(con.left);
		}
	}

	def dispatch void findVariable(LogicExp le, Set<String> variabels){
		le.left.findVariable(variabels);
		le.right.findVariable(variabels);
	}

	def dispatch void findVariable(AllTypes at, Set<String> variabels){
		if(at.id !== null)
		{
			var transform = state.transforms.findFirst[it.name==at.id]
			if(transform === null)
			{
				variabels.add(at.id);
			}
			else
			{
				transform.findTransformVariables(variabels);
			}
		}
	}

	def dispatch void findVariable(LogicComparison con, Set<String> variabels){
		con.left.findVariable(variabels);
		con.right.findVariable(variabels);
	}

	def dispatch generateModelItemMember(Button button)
	'''«generateButton(button.btn)»
	'''

	def findTransformVariables(Transform transform, Set<String> variabels)
	{
		variabels.add(transform.variable);
		if(transform.expression !== null)
			transform.expression.findTransforms(variabels);
	}

	def dispatch void findTransforms(MathExp mat, Set<String> variabels)
	{
		//DO NOTHING
	}

	def dispatch void findTransforms(Value mat, Set<String> variabels)
	{
		//DO NOTHING
	}

	def dispatch void findTransforms(MathOp mat, Set<String> variabels)
	{
		if(mat.left !== null)
			mat.left.findTransforms(variabels)
		if(mat.right !== null)
			mat.right.findTransforms(variabels)
	}

	def dispatch void findTransforms(MathTerm mat, Set<String> variabels)
	{
		if(mat.transform !== null)
			mat.transform.findTransformVariables(variabels);
	}

	def generateButton(ToggleButton buttons)'''
		var toogle«buttons.layer.name» = L.easyButton({
	id: 'easy-button',
    position: '«generateLocation(buttons.location)»',
    states: [{
        icon: getEasybuttonImage«buttons.icon.name»(),
        stateName: 'toggled',
        title: '«buttons.layer.name»',
        onClick: function (btn) {
        	btn.state('detoggled');
            btn.button.style.backgroundColor = 'white';
            «state.mapName».removeLayer(layer«buttons.layer.name»);
        }
    },
	{
        icon: getEasybuttonImage«buttons.icon.name»(),
        stateName: 'detoggled',
        title: '«buttons.layer.name»',
        onClick: function (btn) {
					btn.state('toggled');
					btn.button.style.backgroundColor = 'grey';
					«state.mapName».addLayer(layer«buttons.layer.name»);
				}
			}]
		}).addTo(«state.mapName»);
		toogle«buttons.layer.name».button.style.backgroundColor = 'grey';
	'''

	def dispatch generateLocation(TOPRIGHT location) '''topright'''
	def dispatch generateLocation(TOPLEFT location) '''topleft'''
	def dispatch generateLocation(BOTTOMLEFT location) '''bottomleft'''
	def dispatch generateLocation(BOTTOMRIGHT location) '''bottomright'''

	def dispatch generateModelItemMember(Transform transform) '''
	 function transform«transform.name»(value) {
	 	return «transform.expression.generateTransformExp»;
	 }
	'''

	def dispatch CharSequence generateTransformExp(MathOp exp)
	'''(«exp.left.generateTransformExp»«exp.op.generateTransformExp»«exp.right.generateTransformExp»)'''

	def dispatch CharSequence generateTransformExp(MINUS op)'''-'''
	def dispatch CharSequence generateTransformExp(PLUS op)'''+'''
	def dispatch CharSequence generateTransformExp(MULTIPLI op)'''*'''
	def dispatch CharSequence generateTransformExp(DIVISION op)'''/'''
	def dispatch CharSequence generateTransformExp(Value value)'''value'''


	def dispatch CharSequence generateTransformExp(MathTerm exp)
	'''«IF (exp.transform !== null)»transform«exp.transform.name»(value)«ENDIF»'''

	def dispatch CharSequence generateTransformExp(NumberTypes num)
	'''«IF(num.int !== null)»«printINTEGER(num.int)»«ELSEIF(num.double !== null)»«printDOUBLE(num.double)»«ENDIF»'''


	def dispatch generateModelItemMember(DataSource dataSoruce) '''
	var «dataSoruce.name» = null;
	«var layers = state.layers.filter[it.datasource.name === dataSoruce.name]»
	«IF layers !== null»
		«FOR l : layers»
			var layer«l.name» = null;
		«ENDFOR»
	«ENDIF»
	loadJSON("«dataSoruce.getSourceLocation»",
		(function (data) {
        «dataSoruce.name» = JSON.parse(data);
            «FOR l : layers»
				«IF l.filter.size() !== 0»
	        		«IF l.filter.get(0).expression !== null»
	        			«IF l.filter.get(0).style !== null»		layer«l.name» = L.geoJson(«l.datasource.name», { filter: layer«l.name»Filter1, style: style«l.filter.get(0).style.name» «l.filter.get(0).generateCustumPointIcon»});
	        				«ELSE»		layer«l.name» = L.geoJson(«l.datasource.name», { filter: layer«l.name»Filter1 «l.filter.get(0).generateCustumPointIcon»		});
	        			«ENDIF»
        			«ELSEIF l.filter.get(0).mapType !== null»
	        			«IF l.filter.get(0).style !== null»		layer«l.name» = L.geoJson(«l.datasource.name», { filter: layer«l.name»Filter1, style: style«l.filter.get(0).style.name» «l.filter.get(0).generateCustumPointIcon»});
	        				«ELSE»		layer«l.name» = L.geoJson(«l.datasource.name», { filter: layer«l.name»Filter1 «l.filter.get(0).generateCustumPointIcon»		});
	        			«ENDIF»
	        		«ELSE»
	        			«IF l.filter.get(0).style !== null»		layer«l.name» = L.geoJson(«l.datasource.name», { style: style«l.filter.get(0).style.name» «l.filter.get(0).generateCustumPointIcon»});
	        				«ELSE»		layer«l.name» = L.geoJson(«l.datasource.name» «l.filter.get(0).generateCustumPointIcon»);
	        			«ENDIF»
	        		«ENDIF»
            	«ELSE»
				layer«l.name» = L.geoJson(«l.datasource.name»);
            	«ENDIF»
            	«state.counter = 0»
	            	«FOR filter : l.filter»
		            	«IF state.counter != 0»
		            		«IF filter.expression !== null»
		            			«IF filter.style !== null»		L.geoJson(«l.datasource.name», { filter: layer«l.name»Filter«state.counter+1», style: style«l.filter.get(state.counter).style.name» «filter.generateCustumPointIcon»}).addTo(layer«l.name»);
		            			«ELSE»		L.geoJson(«l.datasource.name», { filter: layer«l.name»Filter«state.counter+1» «filter.generateCustumPointIcon»}).addTo(layer«l.name»);
		            			«ENDIF»
	            			«ELSEIF filter.mapType !== null»
		            			«IF filter.style !== null»		L.geoJson(«l.datasource.name», { filter: layer«l.name»Filter«state.counter+1», style: style«l.filter.get(state.counter).style.name» «filter.generateCustumPointIcon»}).addTo(layer«l.name»);
		            			«ELSE»		L.geoJson(«l.datasource.name», { filter: layer«l.name»Filter«state.counter+1» «filter.generateCustumPointIcon»}).addTo(layer«l.name»);
		            			«ENDIF»
		            		«ELSE»
		            			«IF filter.style !== null»		L.geoJson(«l.datasource.name», {style: style«l.filter.get(state.counter).style.name» «filter.generateCustumPointIcon»}).addTo(layer«l.name»);
		            			«ELSE»		L.geoJson(«l.datasource.name»).addTo(layer«l.name», {«filter.generateCustumPointIcon»});
		            			«ENDIF»
		            		«ENDIF»
		            	«ENDIF»
		            	«state.setCounter(state.counter + 1)»
	            	«ENDFOR»
						layer«l.name».addTo(«state.mapName»);
			«ENDFOR»
	}));
	'''

	def generateCustumPointIcon(Filter filter)'''
	«IF filter.style != null»
		«var makerName = filter.style.findIconStyle»
		«IF makerName !== null»
		,
				    pointToLayer: function(feature, latlng) {
				        return L.marker(latlng, { icon: getIcon«makerName»() });
				    }
		«ENDIF»
	«ENDIF»
	'''

	def String findIconStyle(Styling styling)
	{
		for (element : styling.styles) {
			var results = element.findpointIcon;
			if(results !== null)
				return results;
		}
		if(styling.base !== null)
			return styling.base.findIconStyle
		return null
	}

	def dispatch String findpointIcon(PointerIcon style)
	{
		return style.icon.name;
	}

	def  dispatch String findpointIcon(CSSStyle style)
	{
		return null;
	}



	def generateStaticHTMLBODY()
	'''
		</head>
		<body>
		    <div id="map">
		    </div>
		</body>
		<script>


			function subtractSets(set1, set2) {
					newSet = [];
					for (var i = 0; i < set1.length; i++) {
							index = $.inArray(set1[i], set2);
							if(index == -1) {
									newSet.push(set1[i]);
							}
					}
					return newSet;
			}

			function intersectSets(set1, set2) {
					newSet = [];
					for (var i = 0; i < set1.length; i++) {
							for (var j = 0; j < set2.length; i++) {
									index = $.inArray(set1[i], set2);
									index2 = $.inArray(set2[j], set1);
									if(index != -1 && index2 != -1) {
											newSet.push(set1[i]);
									}
							}
					}
					return newSet;
			}

			function unionSets(set1, set2) {
					return $.merge(set1, set2);
			}

			function containedWithinSet(set, value) {
					return $.inArray(value, set) != -1;
			}

		    function loadJSON(url, callback) {
            var xobj = new XMLHttpRequest();
            xobj.overrideMimeType("application/javascipt");
            //xobj.responseType = 'jsonp';
            xobj.open('GET', url, true);
            xobj.onreadystatechange = function () {
                if (xobj.readyState == 4 && xobj.status == "200") {
                    // .open will NOT return a value but simply returns undefined in async mode so use a callback
                    //console.log(JSON.parse(xobj.responseText));
                    //return xobj.responseText;
                   callback(xobj.responseText);
                }
            }
            xobj.send(null);
        }
	'''

	def generateStatickFooter()
	'''
		</script>
	</html>
	'''

	def generateMaps(Map map) '''
	var «map.mapName» = L.map('map', {
		«generateMapContainterOptions(map.optinals.filter(typeof(MapContainterOptions)).toList())»
	}).setView([«printDOUBLE(map.location.lat)», «printDOUBLE(map.location.long)»], «generateMapOptinalStartZoom(map)»);

	L.tileLayer('«map.mapSource»', {
 		«generateMapTilelayerOptions(map.optinals.filter(typeof(MapTilelayerOptions)).toList())»
	}).addTo(«map.mapName»);
	'''

	def generateMapTilelayerOptions(List<MapTilelayerOptions> mapTilelayerOptions)'''
		«FOR m : mapTilelayerOptions SEPARATOR ','» «generateMapTilelayerOptionsMember(m)»
		«ENDFOR»
	'''

	def printDOUBLE(DOUBLE value)'''«IF(value.value.neq)»-«value.value.value».«value.decimals»«ELSE»«value.value.value».«value.decimals»«ENDIF»'''

	def printINTEGER(INTEGER value)'''«IF(value.neq)»-«value.value»«ELSE»«value.value»«ENDIF»'''

	def dispatch printBOOLEAN(TRUE value)''' true '''

	def dispatch printBOOLEAN(FALSE value)''' false '''

	def dispatch generateMapTilelayerOptionsMember(MinZoom s)'''
	minZoom : «s.zoom»
	'''

	def dispatch generateMapTilelayerOptionsMember(MaxZoom s)'''
	maxZoom : «s.zoom»
	'''

	def dispatch generateMapTilelayerOptionsMember(MaxNativeZoom s)'''
	maxNativeZoom : «s.zoom»
	'''

	def dispatch generateMapTilelayerOptionsMember(ApiKey s)'''
	apikey : '«s.apikey»'
	'''

	def dispatch generateMapTilelayerOptionsMember(Attribution s)'''
	attribution : «s.attribution»
	'''

	def dispatch generateMapTilelayerOptionsMember(KeyValue s)''' «s.key» : «s.value» '''

	def generateMapContainterOptions(List<MapContainterOptions> mapContainterOptions)'''
		«FOR m : mapContainterOptions SEPARATOR ','»
			«generateMapContainterOptionsMember(m)»
		«ENDFOR»
	'''

	def dispatch generateMapContainterOptionsMember(ScrollWheelZoom s)'''
	scrollWheelZoom : «printBOOLEAN(s.inactive)»
	'''

	def dispatch generateMapContainterOptionsMember(DoubleClickZoom s)'''
	doubleClickZoom : «printBOOLEAN(s.inactive)»
	'''

	def dispatch generateMapContainterOptionsMember(DisableZoomBtn s)'''
	zoomControl : «printBOOLEAN(s.inactive)»
	'''

	def dispatch generateMapContainterOptionsMember(KeyboardDisable s)'''
	keyboard : «printBOOLEAN(s.inactive)»
	'''

	def dispatch generateMapContainterOptionsMember(TouchZoomDisable s)'''
	touchZoom : «printBOOLEAN(s.inactive)»
	'''

	def dispatch generateMapContainterOptionsMember(DraggingDisable s)'''
	draggable :  «printBOOLEAN(s.inactive)»
	'''

	def generateMapOptinalStartZoom(Map map)
	'''«var startZoom = map.optinals.filter(typeof(StartZoom))»«IF(!startZoom.nullOrEmpty)»«startZoom.get(0).zoom»«ENDIF»'''

	def generateStaticHeader()'''
	<!DOCTYPE html>
	<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css" />
	    <link rel="stylesheet" href="https://unpkg.com/leaflet-easybutton@2.0.0/src/easy-button.css">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.0/jquery.min.js"></script>
		<script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet.js"></script>
	    <script src="https://unpkg.com/leaflet-easybutton@2.0.0/src/easy-button.js"></script>
		<title>Leaflet DSL</title>
	    <style type="text/css">
	        html, body {
	            height: 100%;
	            margin: 0;
	        }
	        #map {
	            min-height: 100%;
	        }
		</style>
	'''

	def generateInclude(List<Include> includes)
	'''«FOR i : includes»	«generateIncludeMember(i)»«ENDFOR»
	'''

	def dispatch generateIncludeMember(Script s)
	'''
	<script src="«s.source»"></script>
	'''
	def dispatch generateIncludeMember(Style s) '''
	<link rel="stylesheet" href="«s.source»" />
	'''
}
