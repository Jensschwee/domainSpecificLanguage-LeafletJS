/*
 * generated by Xtext 2.11.0
 */
package dk.sdu.mmmi.msd.validation

import org.eclipse.xtext.validation.Check
import dk.sdu.mmmi.msd.leafletDSL.Filter
import dk.sdu.mmmi.msd.leafletDSL.Layer
import dk.sdu.mmmi.msd.leafletDSL.DataSourceVariable
import org.eclipse.emf.common.util.EList
import java.util.Set
import java.util.HashSet
import org.eclipse.xtext.Disjunction
import org.eclipse.xtext.Conjunction
import dk.sdu.mmmi.msd.leafletDSL.LogicExp
import dk.sdu.mmmi.msd.leafletDSL.LogicExpression
import dk.sdu.mmmi.msd.leafletDSL.AllTypes
import dk.sdu.mmmi.msd.leafletDSL.Comparison
import dk.sdu.mmmi.msd.leafletDSL.Transform
import dk.sdu.mmmi.msd.leafletDSL.MathOp
import dk.sdu.mmmi.msd.leafletDSL.MathTerm
import javax.swing.text.LayeredHighlighter.LayerPainter
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.EClass
import dk.sdu.mmmi.msd.leafletDSL.DataSource
import dk.sdu.mmmi.msd.leafletDSL.Value
import dk.sdu.mmmi.msd.leafletDSL.Style
import dk.sdu.mmmi.msd.leafletDSL.Styling
import dk.sdu.mmmi.msd.leafletDSL.LeafletDSLPackage
import dk.sdu.mmmi.msd.leafletDSL.LogicComparison
import dk.sdu.mmmi.msd.leafletDSL.SetComparison
import dk.sdu.mmmi.msd.leafletDSL.SetTypes

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class StateClass {
    @Property
    var Set<Transform> transforms = new HashSet();
     @Property
    var Set<DataSource> datasources = new HashSet();
}

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class LeafletDSLValidator extends AbstractLeafletDSLValidator {

//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital',
//					DomainmodelPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	var state = new StateClass();

	def Set<String> findVariabelsForFilter(LogicExpression dis){
			var variabels = new HashSet<String>();
			dis.findFilterVariables(variabels);
			return variabels;
	}

	def Set<String> findFilterVariables(LogicExpression dis) {
		var variabels = new HashSet<String>();
		dis.findFilterVariables(variabels);
		return variabels;
	}

	def dispatch void findFilterVariables(Disjunction di, Set<String> variabels){
		di.left.findFilterVariables(variabels);
		di.right.findFilterVariables(variabels);
	}

	def dispatch void findFilterVariables(Conjunction con, Set<String> variabels){
		con.left.findFilterVariables(variabels);
		con.right.findFilterVariables(variabels);
	}

	def dispatch void findFilterVariables(LogicExp le, Set<String> variabels){
		le.left.findFilterVariables(variabels);
		le.right.findFilterVariables(variabels);
	}

	def dispatch void findFilterVariables(AllTypes at, Set<String> variabels){
		if(!at.id.isNullOrEmpty())
		{
			var transform = state.transforms.findFirst[it.name==at.id]
			if(transform === null)
			{
				variabels.add(at.id);
			}
			else
			{
				transform.findTransformVariables(variabels);
			}
		}
	}

	def findTransformVariables(Transform transform, Set<String> variabels)
	{
		variabels.add(transform.variable);
		if(transform.expression !== null)
			transform.expression.findTransforms(variabels);
	}

	def dispatch void findTransforms(Value mat, Set<String> variabels)
	{

	}

	def dispatch void findTransforms(MathOp mat, Set<String> variabels)
	{
		if(mat.left !== null)
			mat.left.findTransforms(variabels)
		if(mat.right !== null)
			mat.right.findTransforms(variabels)
	}

	def dispatch void findTransforms(MathTerm mat, Set<String> variabels)
	{
		if(mat.transform !== null)
			mat.transform.findTransformVariables(variabels);
	}

	def dispatch void findFilterVariables(LogicComparison con, Set<String> variabels){
		con.left.findFilterVariables(variabels);
		con.right.findFilterVariables(variabels);
	}

	def dispatch void findFilterVariables(SetComparison con, Set<String> variabels){
		con.right.findFilterVariables(variabels);
	}

	def dispatch void findFilterVariables(SetTypes st, Set<String> variabels){
		// TODO: Do something here
	}

	def dispatch void findFilterVariables(Comparison con, Set<String> variabels) {
	}

	@Check
	def checkFilterDatasoruces(Filter filter) {
		if(filter.expression != null )
		{
			var layer =	filter.eContainer() as Layer;
			var variables =  filter.expression.findVariabelsForFilter;
			var datasoruceVar = new HashSet<String>;

			for (variable : layer.datasource.variables)
			{
				datasoruceVar.add(variable.vname);
			}
			for (variable : variables)
			{
				if(!datasoruceVar.contains(variable))
					error("All variables must be defined under the datasource: \n Datasource '" +  layer.datasource.name + "' does not have variable '" + variable + "'", LeafletDSLPackage$Literals::FILTER__EXPRESSION);
			}

		 }
	}

	@Check
	def checkTransform(Transform transform) {
		state.transforms.add(transform);

	}

	@Check
	def checkStyling(Styling styling) {
		var stylings = new HashSet<String>();
		stylings.add(styling.name);
		if(styling.base !== null)
		{
			styling.base.checkSubStyle(stylings);
		}
	}

	def checkSubStyle(Styling styling, Set<String> stylings)
	{
		if(stylings.contains(styling.name))
		{
			error("Style may not have circular references Style: '" +  styling.name +"' have", LeafletDSLPackage$Literals::STYLING__NAME);
		}
		else
		{
			stylings.add(styling.name);
			if(styling.base !== null)
			{
				styling.base.checkSubStyle(stylings);
			}
		}
	}

	@Check
	def addDataSourceToList(DataSource datasource) {
		state.datasources.add(datasource);
	}

}
