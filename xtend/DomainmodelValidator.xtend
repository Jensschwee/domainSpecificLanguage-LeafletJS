/*
 * generated by Xtext 2.11.0
 */
package org.example.domainmodel.validation

import org.eclipse.xtext.validation.Check
import org.example.domainmodel.domainmodel.Filter
import org.example.domainmodel.domainmodel.Layer
import org.example.domainmodel.domainmodel.DataSourceVariable
import org.eclipse.emf.common.util.EList
import java.util.Set
import java.util.HashSet
import org.eclipse.xtext.Disjunction
import org.eclipse.xtext.Conjunction
import org.example.domainmodel.domainmodel.LogicExp
import org.example.domainmodel.domainmodel.LogicExpression
import org.example.domainmodel.domainmodel.AllTypes
import org.example.domainmodel.domainmodel.Comparison
import org.example.domainmodel.domainmodel.Transform
import org.example.domainmodel.domainmodel.MathOp
import org.example.domainmodel.domainmodel.MathTerm
import javax.swing.text.LayeredHighlighter.LayerPainter
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.EClass
import org.example.domainmodel.domainmodel.DomainmodelPackage
import org.example.domainmodel.domainmodel.DataSource
import org.example.domainmodel.domainmodel.Value
import org.example.domainmodel.domainmodel.Style
import org.example.domainmodel.domainmodel.Styling
import org.example.domainmodel.domainmodel.MathExp
import org.example.domainmodel.domainmodel.DataSourceVariableType
import org.example.domainmodel.domainmodel.BOOLEAN
import org.example.domainmodel.domainmodel.Bool
import org.example.domainmodel.domainmodel.impl.BoolImpl
import org.example.domainmodel.domainmodel.LESS
import org.example.domainmodel.domainmodel.NOT
import org.example.domainmodel.domainmodel.EQMORE
import org.example.domainmodel.domainmodel.EQLESS
import org.example.domainmodel.domainmodel.EQ
import org.example.domainmodel.domainmodel.MORE
import org.example.domainmodel.domainmodel.LeafletVersion
import org.example.domainmodel.domainmodel.FilterMapType
import org.example.domainmodel.domainmodel.FilterStyle
import org.example.domainmodel.domainmodel.LineColor
import org.example.domainmodel.domainmodel.LineWidth
import org.example.domainmodel.domainmodel.BackgroundColor
import org.example.domainmodel.domainmodel.BackgroundOpacity
import org.example.domainmodel.domainmodel.PointerIcon
import org.example.domainmodel.domainmodel.LineOpacity
import org.example.domainmodel.domainmodel.Id
import org.example.domainmodel.domainmodel.NumberTypes

public enum DataTypes {
    BOOLIAN, STRING, NUMBER
}

class StateClass {  
    @Property
    var Set<Transform> transforms = new HashSet();    
}

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DomainmodelValidator extends AbstractDomainmodelValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					DomainmodelPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	var state = new StateClass();
	
	@Check
	def checkLeafletVersion(LeafletVersion vesion)
	{
		if(!vesion.version.equals("1.0.3"))
		{
			info("Only supports the version 1.0.3", DomainmodelPackage$Literals::LEAFLET_VERSION__VERSION)
		}
	}

	def Set<String> findVariabelsForFilter(LogicExpression dis){
			var variabels = new HashSet<String>();
			dis.findFilterVariables(variabels);
			return variabels;
	}

	def Set<String> findFilterVariables(LogicExpression dis) {
		var variabels = new HashSet<String>();
		dis.findFilterVariables(variabels);
		return variabels;
	}
	
	def dispatch void findFilterVariables(Disjunction di, Set<String> variabels){
		if(di.left !== null)
			di.left.findFilterVariables(variabels);
		if(di.right !== null)
			di.right.findFilterVariables(variabels);
	}
	
	def dispatch void findFilterVariables(Conjunction con, Set<String> variabels){
		if(con.left !== null)
			con.left.findFilterVariables(variabels);
		if(con.right !== null)
			con.right.findFilterVariables(variabels);
	}
	
	def dispatch void findFilterVariables(LogicExp le, Set<String> variabels){
		if(le.left !== null)
			le.left.findFilterVariables(variabels);
		if(le.right !== null)
			le.right.findFilterVariables(variabels);
	}
	
	/*
	def dispatch void findFilterVariables(AllTypes at, Set<String> variabels){
		if(!at.id.isNullOrEmpty())
		{
			var transform = state.transforms.findFirst[it.name==at.id]
			if(transform === null)
			{
				variabels.add(at.id);
			}
			else
			{
				transform.findTransformVariables(variabels);
			}
		}
	} */
	
	def dispatch void findFilterVariables(Id id, Set<String> variabels){
		var transform = state.transforms.findFirst[it.name==id.id]
		if(transform === null)
		{
			variabels.add(id.id);
		}
		else
		{
			transform.findTransformVariables(variabels);
		}
	}
	
	def dispatch void findFilterVariables(AllTypes type, Set<String> variabels){
		//DO NOTHING
	}
	
	def findTransformVariables(Transform transform, Set<String> variabels)
	{
		variabels.add(transform.variable);
		if(transform.expression !== null)
			transform.expression.findTransforms(variabels);
	}
	
	def dispatch void findTransforms(Value mat, Set<String> variabels)
	{
		
	}
	
	def dispatch void findTransforms(MathOp mat, Set<String> variabels)
	{
		if(mat.left !== null)
			mat.left.findTransforms(variabels)
		if(mat.right !== null)	
			mat.right.findTransforms(variabels)
	}
	
	def dispatch void findTransforms(MathTerm mat, Set<String> variabels)
	{
		if(mat.transform !== null)
			mat.transform.findTransformVariables(variabels);
	}
	
	def dispatch void findFilterVariables(Comparison con, Set<String> variabels){
		con.left.findFilterVariables(variabels);
		if(con.right !== null)
			con.right.findFilterVariables(variabels);
	}
	
	@Check
	def checkFilterDatasoruces(Filter filter) {
		
		var expressionList = filter.filterElements.filter(LogicExpression);
		var mapTypeList = filter.filterElements.filter(FilterMapType);
		var styleList = filter.filterElements.filter(FilterStyle);
		
		if(mapTypeList.size > 1)
		{
			var index = filter.filterElements.indexOf(mapTypeList.get(mapTypeList.size-1));
			error("Filter can only have one type element", DomainmodelPackage$Literals::FILTER__FILTER_ELEMENTS,index);		 	 
		}
		
		if(styleList.size > 1)
		{
			var index = filter.filterElements.indexOf(styleList.get(styleList.size-1));
			error("Filter can only have one styling element", DomainmodelPackage$Literals::FILTER__FILTER_ELEMENTS,index);		 	 
		}
		
		if(expressionList.size == 1)
		{
			var expression = expressionList.get(0);
			var expressionIndex = filter.filterElements.indexOf(expression);
			var layer =	filter.eContainer() as Layer;
			var variables =  expression.findVariabelsForFilter;
			var datasoruceVar = new HashSet<String>;
			
			for (variable : layer.datasource.variables)
			{
				datasoruceVar.add(variable.vname);
			}
			for (variable : variables)
			{
				if(!datasoruceVar.contains(variable))
					error("All variables must be defined under the datasource: \n Datasource '" +  layer.datasource.name + "' does not have variable '" + variable + "'", DomainmodelPackage$Literals::FILTER__FILTER_ELEMENTS,expressionIndex);		 	 
			}
			expression.checkDatatypeExp(layer.datasource.variables, expressionIndex);
		 }
		 else if(expressionList.size > 1)
		 {
		 	var index = filter.filterElements.indexOf(expressionList.get(expressionList.size-1));
			error("Filter can only have one where element", DomainmodelPackage$Literals::FILTER__FILTER_ELEMENTS,index);
		 }
	}
	
	@Check
	def checkTransform(Transform transform) {
		state.transforms.add(transform);
		
	}
	
	@Check
	def checkStyling(Styling styling) {
		var stylings = new HashSet<String>();
		stylings.add(styling.name);
		if(styling.base !== null)
		{
			styling.base.checkSubStyle(stylings);
		}
		styling.stylingCSSElements;
	}
	
	def stylingCSSElements(Styling styling){
		if(styling.styles.size > 1)
		{
			var lineColor = styling.styles.filter(LineColor);
			if(lineColor.size > 1)
			{
				var index = styling.styles.indexOf(lineColor.get(lineColor.size-1));
				error("Style LineColor can only be defined once", DomainmodelPackage$Literals::STYLING__STYLES, index);		 	 
			}
			
			var lineWidth = styling.styles.filter(LineWidth);
			if(lineWidth.size > 1)
			{
				var index = styling.styles.indexOf(lineWidth.get(lineWidth.size-1));
				error("Style LineWidth can only be defined once", DomainmodelPackage$Literals::STYLING__STYLES, index);		 	 
			}
			
			var backgroundColor = styling.styles.filter(BackgroundColor);
			if(backgroundColor.size > 1)
			{
				var index = styling.styles.indexOf(backgroundColor.get(backgroundColor.size-1));
				error("Style BackgroundColor can only be defined once", DomainmodelPackage$Literals::STYLING__STYLES, index);		 	 
			}
			
			var backgroundOpacity = styling.styles.filter(BackgroundOpacity);
			if(backgroundOpacity.size > 1)
			{
				var index = styling.styles.indexOf(backgroundOpacity.get(backgroundOpacity.size-1));
				error("Style BackgroundOpacity can only be defined once", DomainmodelPackage$Literals::STYLING__STYLES, index);		 	 
			}
			
			var pointerIcon = styling.styles.filter(PointerIcon);
			if(pointerIcon.size > 1)
			{
				var index = styling.styles.indexOf(pointerIcon.get(pointerIcon.size-1));
				error("Style PointerIcon can only be defined once", DomainmodelPackage$Literals::STYLING__STYLES, index);		 	 
			}
			
			var lineOpacity = styling.styles.filter(LineOpacity);
			if(lineOpacity.size > 1)
			{
				var index = styling.styles.indexOf(lineOpacity.get(lineOpacity.size-1));
				error("Style LineOpacity can only be defined once", DomainmodelPackage$Literals::STYLING__STYLES, index);		 	 
			}
		}
	}
	
	def checkSubStyle(Styling styling, Set<String> stylings)
	{
		if(stylings.contains(styling.name))
		{
			error("Style may not have circular references Style: '" +  styling.name +"' have", DomainmodelPackage$Literals::STYLING__NAME);		 	 
		}
		else
		{
			stylings.add(styling.name);
			if(styling.base !== null)
			{
				styling.base.checkSubStyle(stylings);
			}
		}
	}
	
	def void checkDatatypeExp(LogicExpression exp,EList<DataSourceVariable> variables, int expressionIndex) {
		exp.checkDatatypeFilterExp(variables, expressionIndex);
	}
	
	def dispatch DataTypes checkDatatypeFilterExp(LogicExp exp,EList<DataSourceVariable> variables, int expressionIndex) {
		if(exp.left !== null)
			exp.left.checkDatatypeFilterExp(variables, expressionIndex);
		if(exp.right !== null)
			exp.right.checkDatatypeFilterExp(variables, expressionIndex);
		return null;
	}
	
	def dispatch DataTypes checkDatatypeFilterExp(Comparison com, EList<DataSourceVariable> variables, int expressionIndex){
		if(com.left !== null)
		{
			var type1 = com.left.checkDatatypeFilterExp(variables, expressionIndex);
			if(com.right !== null && com.operator !== null)
			{
				var type2 = com.right.checkDatatypeFilterExp(variables, expressionIndex);
				com.operator.checkDatatypes(type1, type2, expressionIndex);
			}
		}
		return null;
	}
	
	def dispatch DataTypes checkDatatypeFilterExp(Disjunction di, EList<DataSourceVariable> variables, int expressionIndex){
		if(di.left !== null)
			di.left.checkDatatypeFilterExp(variables, expressionIndex);
		if(di.right !== null)
		{
			di.right.checkDatatypeFilterExp(variables, expressionIndex);
		}
		return null;
	}
	
	def dispatch DataTypes checkDatatypeFilterExp(Conjunction con, EList<DataSourceVariable> variables, int expressionIndex){
		if(con.left !== null)
			con.left.checkDatatypeFilterExp(variables, expressionIndex);
		if(con.right !== null)
		{
			con.right.checkDatatypeFilterExp(variables, expressionIndex);
		}
		return null;
	}
	
	def dispatch DataTypes checkDatatypeFilterExp(MathTerm datatype,EList<DataSourceVariable> variables, int expressionIndex) {
		return DataTypes.NUMBER;
	}
	
	def dispatch DataTypes checkDatatypeFilterExp(BOOLEAN datatype,EList<DataSourceVariable> variables, int expressionIndex) {
		return DataTypes.BOOLIAN;
	}
	
	def dispatch DataTypes checkDatatypeFilterExp(Id id,EList<DataSourceVariable> variables, int expressionIndex){
		var transform = state.transforms.findFirst[it.name==id.id]
			if(transform !== null)
			{
				return transform.checkDatatypeFilterExp(variables, expressionIndex);
			}
			else
			{
				var type = variables.findFirst[it.vname == id.id].type;
				if(type !== null)
					return type.checkDatatypeFilterExp(variables, expressionIndex);
			}
	}
	
	/*
	def dispatch DataTypes checkDatatypeFilterExp(AllTypes datatype,EList<DataSourceVariable> variables, int expressionIndex) {
		if(!datatype.id.isNullOrEmpty)
		{
			var transform = state.transforms.findFirst[it.name==datatype.id]
			if(transform !== null)
			{
				return transform.checkDatatypeFilterExp(variables, expressionIndex);
			}
			else
			{
				var type = variables.findFirst[it.vname == datatype.id].type;
				if(type !== null)
					return type.checkDatatypeFilterExp(variables, expressionIndex);
			}
		}
		else
		{
			return DataTypes.STRING;
		}
	} */
		
	def dispatch DataTypes checkDatatypeFilterExp(Transform transform,EList<DataSourceVariable> variables, int expressionIndex) {
		var datatype = variables.findFirst[it.vname == transform.variable].type.checkDatatypeFilterExp(variables, expressionIndex);
		if(!datatype.equals(DataTypes.NUMBER))
		{
			var datasoruce =	variables.findFirst[it.vname == transform.variable].eContainer as DataSource;
			error("Transform " + transform.name + " can not use this input. \n Only supports numbers. \n variable " + transform.variable + " is not a number in the data source " + datasoruce.name, DomainmodelPackage$Literals::FILTER__FILTER_ELEMENTS,expressionIndex);
		}
		return datatype;
	}
	
	
	def dispatch DataTypes checkDatatypeFilterExp(org.example.domainmodel.domainmodel.String datatype,EList<DataSourceVariable> variables, int expressionIndex) {
		return DataTypes.STRING;
	}
	
	
	def dispatch DataTypes checkDatatypeFilterExp(org.example.domainmodel.domainmodel.Number datatype,EList<DataSourceVariable> variables, int expressionIndex) {
		return DataTypes.NUMBER;
	}
	
	def dispatch DataTypes checkDatatypeFilterExp(org.example.domainmodel.domainmodel.Bool datatype,EList<DataSourceVariable> variables, int expressionIndex) {
		return DataTypes.BOOLIAN;
	}
	
	def Boolean isDatatypesEquals(DataTypes type1, DataTypes type2, int expressionIndex)
	{
		if(!type1.equals(type2))
		{
			warning("These data types are not the same and will always be false", DomainmodelPackage$Literals::FILTER__FILTER_ELEMENTS,expressionIndex);		 	 
			return false;
		}
		return true;
	}
	
	def dispatch checkDatatypes(LESS less, DataTypes type1, DataTypes type2, int expressionIndex)
	{
		if(type1.isDatatypesEquals(type2, expressionIndex))
		{
			switch (type1) {
				case DataTypes.BOOLIAN: {
					boolErrorMsg("LESS", expressionIndex)
				}
				case DataTypes.STRING: {
					stringErrorMsg("LESS", expressionIndex);
				}
				case NUMBER: {
					//THIS IS FINE
				}
			}
		}
	}
	def dispatch checkDatatypes(MORE less, DataTypes type1, DataTypes type2, int expressionIndex)
	{
		if(type1.isDatatypesEquals(type2,expressionIndex))
		{
			switch (type1) {
				case DataTypes.BOOLIAN: {
					boolErrorMsg("MORE", expressionIndex)
				}
				case DataTypes.STRING: {
					stringErrorMsg("MORE", expressionIndex);
				}
				case NUMBER: {
					//THIS IS FINE
				}
			}
		}
	}
	def dispatch checkDatatypes(EQ eq, DataTypes type1, DataTypes type2, int expressionIndex)
	{
		type1.isDatatypesEquals(type2,expressionIndex);		
	}
	def dispatch checkDatatypes(EQLESS eqless, DataTypes type1, DataTypes type2, int expressionIndex)
	{
		if(type1.isDatatypesEquals(type2,expressionIndex))
		{
			switch (type1) {
				case DataTypes.BOOLIAN: {
					boolErrorMsg("EQUAL or LESS", expressionIndex)
				}
				case DataTypes.STRING: {
					stringErrorMsg("EQUAL or LESS", expressionIndex);
				}
				case NUMBER: {
					//THIS IS FINE
				}
			}
		}
	}
	def dispatch checkDatatypes(EQMORE eqmore, DataTypes type1, DataTypes type2, int expressionIndex)
	{
		if(type1.isDatatypesEquals(type2,expressionIndex))
		{
			switch (type1) {
				case DataTypes.BOOLIAN: {
					boolErrorMsg("EQUAL or MORE", expressionIndex)
				}
				case DataTypes.STRING: {
					stringErrorMsg("EQUAL or MORE", expressionIndex);
				}
				case NUMBER: {
					//THIS IS FINE
				}
			}
		}
	}
	def dispatch checkDatatypes(NOT not, DataTypes type1, DataTypes type2, int expressionIndex)
	{
		if(!type1.equals(type2))
			info("These data types are not the same and will always be true, in the not case", DomainmodelPackage$Literals::FILTER__FILTER_ELEMENTS,expressionIndex);		 	 
	}
	
	def stringErrorMsg(String type, int expressionIndex)
	{
		error("Strings can not handle operator " + type, DomainmodelPackage$Literals::FILTER__FILTER_ELEMENTS,expressionIndex);
	}
	
	def boolErrorMsg(String type, int expressionIndex)
	{
		error("Booleans can not handle operator " + type, DomainmodelPackage$Literals::FILTER__FILTER_ELEMENTS,expressionIndex);
	}
}