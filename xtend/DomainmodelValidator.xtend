/*
 * generated by Xtext 2.11.0
 */
package dk.sdu.mmmi.msd.validation

import org.eclipse.xtext.validation.Check
import dk.sdu.mmmi.msd.leafletDSL.Filter
import dk.sdu.mmmi.msd.leafletDSL.Layer
import dk.sdu.mmmi.msd.leafletDSL.DataSourceVariable
import org.eclipse.emf.common.util.EList
import java.util.Set
import java.util.HashSet
import org.eclipse.xtext.Disjunction
import org.eclipse.xtext.Conjunction
import dk.sdu.mmmi.msd.leafletDSL.LogicExp
import dk.sdu.mmmi.msd.leafletDSL.LogicExpression
import dk.sdu.mmmi.msd.leafletDSL.AllTypes
import dk.sdu.mmmi.msd.leafletDSL.Comparison
import dk.sdu.mmmi.msd.leafletDSL.Transform
import dk.sdu.mmmi.msd.leafletDSL.MathOp
import dk.sdu.mmmi.msd.leafletDSL.MathTerm
import javax.swing.text.LayeredHighlighter.LayerPainter
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.EClass
import dk.sdu.mmmi.msd.leafletDSL.DataSource
import dk.sdu.mmmi.msd.leafletDSL.Value
import dk.sdu.mmmi.msd.leafletDSL.Style
import dk.sdu.mmmi.msd.leafletDSL.Styling
import dk.sdu.mmmi.msd.leafletDSL.LeafletDSLPackage
import dk.sdu.mmmi.msd.leafletDSL.LogicComparison
import dk.sdu.mmmi.msd.leafletDSL.SetComparison
import dk.sdu.mmmi.msd.leafletDSL.SetTypes
import dk.sdu.mmmi.msd.leafletDSL.AllSetTypes
import dk.sdu.mmmi.msd.leafletDSL.NumberTypes
import org.eclipse.emf.ecore.EObject
import dk.sdu.mmmi.msd.leafletDSL.Assignment

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class StateClass {
    @Property
    var Set<Transform> transforms = new HashSet();
     @Property
    var Set<DataSource> datasources = new HashSet();
     @Property
    var Set<Assignment> assignments = new HashSet();
}

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class LeafletDSLValidator extends AbstractLeafletDSLValidator {

//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital',
//					DomainmodelPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	var state = new StateClass();

	def Set<String> findVariabelsForFilter(LogicExpression dis){
			var variabels = new HashSet<String>();
			dis.findFilterVariables(variabels);
			return variabels;
	}

	def Set<String> findFilterVariables(LogicExpression dis) {
		var variabels = new HashSet<String>();
		dis.findFilterVariables(variabels);
		return variabels;
	}

	def dispatch void findFilterVariables(Disjunction di, Set<String> variabels){
		di.left.findFilterVariables(variabels);
		di.right.findFilterVariables(variabels);
	}

	def dispatch void findFilterVariables(Conjunction con, Set<String> variabels){
		con.left.findFilterVariables(variabels);
		con.right.findFilterVariables(variabels);
	}

	def dispatch void findFilterVariables(LogicExp le, Set<String> variabels){
		le.left.findFilterVariables(variabels);
		le.right.findFilterVariables(variabels);
	}

	def dispatch void findFilterVariables(AllTypes at, Set<String> variabels){
		if(!at.id.isNullOrEmpty())
		{
			var transform = state.transforms.findFirst[it.name==at.id]
			if(transform === null)
			{
				variabels.add(at.id);
			}
			else
			{
				transform.findTransformVariables(variabels);
			}
		}
	}

	def findTransformVariables(Transform transform, Set<String> variabels)
	{
		variabels.add(transform.variable);
		if(transform.expression !== null)
			transform.expression.findTransforms(variabels);
	}

	def dispatch void findTransforms(Value mat, Set<String> variabels)
	{

	}

	def dispatch void findTransforms(MathOp mat, Set<String> variabels)
	{
		if(mat.left !== null)
			mat.left.findTransforms(variabels)
		if(mat.right !== null)
			mat.right.findTransforms(variabels)
	}

	def dispatch void findTransforms(MathTerm mat, Set<String> variabels)
	{
		if(mat.transform !== null)
			mat.transform.findTransformVariables(variabels);
	}

	def dispatch void findFilterVariables(LogicComparison con, Set<String> variabels){
		con.left.findFilterVariables(variabels);
		con.right.findFilterVariables(variabels);
	}

	def dispatch void findFilterVariables(SetComparison con, Set<String> variabels){
		if(con.left !== null) {
			variabels.add(con.left);
		}
	}

	def dispatch void findFilterVariables(SetTypes st, Set<String> variabels) {
		// Ignore
	}

	def dispatch void findFilterVariables(Comparison con, Set<String> variabels) {
		// Ignore
	}

	@Check
	def checkFilterDatasoruces(Filter filter) {
		if(filter.expression != null )
		{
			var layer =	filter.eContainer() as Layer;
			var variables =  filter.expression.findVariabelsForFilter;
			var datasoruceVar = new HashSet<String>;

			for (variable : layer.datasource.variables)
			{
				datasoruceVar.add(variable.vname);
			}
			for (variable : variables)
			{
				if(!datasoruceVar.contains(variable))
					error("All variables must be defined under the datasource: \n Datasource '" +  layer.datasource.name + "' does not have variable '" + variable + "'", LeafletDSLPackage$Literals::FILTER__EXPRESSION);
			}

		 }
	}

	@Check
	def checkTransform(Transform transform) {
		state.transforms.add(transform);

	}

	@Check
	def checkStyling(Styling styling) {
		var stylings = new HashSet<String>();
		stylings.add(styling.name);
		if(styling.base !== null)
		{
			styling.base.checkSubStyle(stylings);
		}
	}

	def checkSubStyle(Styling styling, Set<String> stylings)
	{
		if(stylings.contains(styling.name))
		{
			error("Style may not have circular references Style: '" +  styling.name +"' have", LeafletDSLPackage$Literals::STYLING__NAME);
		}
		else
		{
			stylings.add(styling.name);
			if(styling.base !== null)
			{
				styling.base.checkSubStyle(stylings);
			}
		}
	}

	@Check
	def addDataSourceToList(DataSource datasource) {
		state.datasources.add(datasource);
	}

	@Check
	def ensureSetSingleType(dk.sdu.mmmi.msd.leafletDSL.Set set) {
		var firstItemType = "";
		var index = 0
		for(AllSetTypes setitem : set.items) {
			if(firstItemType === "") {
				if(setitem.s !== null) {
					firstItemType = "string"
				}
				else if(setitem instanceof NumberTypes) {
					firstItemType = "number"
				}
			}

			if(firstItemType === "string" && setitem.s === null) {
				error("Expected 'string', all items within a set must of be the same type.", LeafletDSLPackage$Literals::SET__ITEMS, index);
			}
			else if(firstItemType === "number" && !(setitem instanceof NumberTypes)) {
				error("Expected 'number', all items within a set must be of the same type.", LeafletDSLPackage$Literals::SET__ITEMS, index);
			}
			index++
		}
	}

	@Check
	def ensureSetComparisonVariablePresence(SetComparison setComp) {
		var DataSource dataSource = findLayerDataSource(setComp)
		for(DataSourceVariable variable : dataSource.variables) {
			if(variable.vname.equals(setComp.left)) {
				return;
			}
		}
		error("Expected '" + setComp.left + "' to be present as a variable within the datasource named '" + dataSource.name + "'", LeafletDSLPackage$Literals::SET_COMPARISON__LEFT);
	}


	def dispatch DataSource findLayerDataSource(SetComparison setComp) {
		return setComp.eContainer().findLayerDataSource as DataSource
	}

	def dispatch DataSource findLayerDataSource(EObject object) {
		if(object instanceof Layer) {
			var Layer layer = object as Layer
			if(layer.datasource !== null) {
				return layer.datasource
			}
		}
		return object.eContainer().findLayerDataSource
	}

	@Check
	def addVariableAssignments(Assignment ass) {
		state.assignments.add(ass)
	}

	@Check
	def ensureReferencedAssignedSetPresence(SetTypes setTypes) {
		if(setTypes.id === null) {
			return
		}

		for(Assignment ass : state.assignments) {
			if(ass.name.equals(setTypes.id) && ass.exp instanceof dk.sdu.mmmi.msd.leafletDSL.Set) {
				return;
			}
		}
		error("Identifier '" + setTypes.id + "' is not assigned a set.", LeafletDSLPackage$Literals::SET_TYPES__ID);
	}

}
